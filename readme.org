This program calculates the Steenrod higher diagonals of a linear combination of simplices. 
* representation
** simplex
   A simplex is represented as a list where the first element is :simplex and the second element is a vector of integers naming vertices, e.g.
   #+begin_src lisp
   '(:simplex #(0 1 2 3))
   #+end_src
** linear combination
   A list starting with + indicates a sum, a list '(k vec) denotes scaling a vector by k
   #+begin_src lisp
   '(+ (2 x) (3 y))
   #+end_src
** permutation
   A permutation is denoted by a list matching the standard notation, i.e. (1 2 3) sends 1->2->3->1
** Ring of scalars
   The ring of scalars is currently Z/2Z by default. To change it, rebind the (dynamic) variable *base*, i.e.
#+begin_src lisp
(let ((*base* nil)) ;;; to use Z
  (xi 1 (standard-simp 2)))
(let ((*base 3))  ;;; to use Z/3Z
  (xi 2 (standard-simp 3)))
#+end_src
   In Z/2Z, coefficients are removed after processing. 
* computing things
** steenrod diagonals
  To calculate the n-th steenrod diagonal of expr, you use 
  #+begin_src lisp
(xi n expr)
  #+end_src
** permutations of tensors
*** collapsing tensors
   Most of the code (at the moment) assumes that tensors are always arity 2. To take permutations of tensors, you have to first call flatten-tensor, which will walk the tree you input and reduce all nested tensors to one higher-arity tensor.
*** permuting tensors 
    To invoke the permutation (p1 p2 ... p3) on all tensors in the expression expr, use
    #+begin_src lisp
(permute-tensor '(p1 p2 ... p3) expr)
    #+end_src
* operad trees
** representation
   The operad tree 
   #+begin_src text
1  2 3
 \/ /
 1\/
  0
   #+end_src 
   is represented by 
   #+begin_src lisp
'(:delta 0 (:delta 1 1 2) 3)
   #+end_src
** derivative
   To take the derivative/boundary of an operad tree, call derivative
   #+begin_src lisp
(derivative '(:delta 0 (:delta 1 1 2) 3))
   #+end_src
** evaluate operad
   To do this, call 
   #+begin_src lisp
(call-optree '(:delta 0 (:delta 0 2 1) 3) (standard-simp 3))
   #+end_src
